/*
 * generated by Xtext 2.9.0
 */
package de.htwberlin.selabs.pml.tests

import com.google.inject.Inject
import de.htwberlin.selabs.pml.pmlDsl.PmlModel
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.junit4.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import org.eclipse.xtext.junit4.validation.ValidationTestHelper

@RunWith(XtextRunner)
@InjectWith(PmlDslInjectorProvider)
class PmlDslParsingTest{


	@Inject
	ParseHelper<PmlModel> parseHelper;
	@Inject extension ValidationTestHelper
	
	val inp1 = '''
		mtype = {Cop, Criminal, Mom, Dad, Girl, Boy, Boat};
					
		#define DONE (r[Cop] == 1 && r[Criminal] == 1 && 
					  r[Mom] == 1 && r[Dad] == 1 && 
					  r[Girl] == 2 && r[Boy] == 2 && r[Boat] == 1)
					  
		int r[8];			  
	'''
	
	val inp2 = '''
				#define NotWith(children, with) (r[children] == 2*(1-r[with]))
				#define With(children, with)    (r[children] != 2*(1-r[with]))
	
				#define CriminalUnsafe (r[Criminal] != r[Cop] && CriminalUnsafeSub) 
				// new function to avoid parenthesis on fml
				#define CriminalUnsafeSub 
	        		(r[Criminal] == r[Mom] || r[Criminal] == r[Dad] || 
	        		With(Boy,Criminal) || With(Girl,Criminal) )
	
				#define BoysUnsafe ( With(Boy,Mom) && r[Mom]!=r[Dad] )
				#define GirlsUnsafe ( With(Girl,Dad) && r[Mom]!=r[Dad] )
	'''
	
	val inp3 = '''
	mtype prev_dr   = 0;
	mtype prev_pass = 0;
	
	inline printMove(driver, passenger, boat)
	{
	    if
	        :: boat == 0 ->
	            if
	            :: passenger == 0 ->
	                printf("%e goes there alone.\n", driver); 
	            :: else  ->   
	                printf("%e with %e go there.\n", driver, passenger); 
	            fi;    
	        :: else ->
	            if
	            :: passenger == 0 ->
	                printf("%e goes back alone.\n", driver); 
	            :: else  ->   
	                printf("%e with %e go back.\n", driver, passenger); 
	            fi;    
	    fi;    
	}'''
	
	val inp4 = '''
	inline update_r()
	{
	  r[driver] = r[driver] + (1-2*r[Boat]);
	  if 
	     :: passenger != 0 -> r[passenger] = r[passenger] + (1-2*r[Boat]);
	     :: else -> skip;
	  fi;
	  r[Boat] = 1 - r[Boat];
	}
	
	'''
	
	val inp5 = '''
	inline move(dr, pass)
	{
	  printMove(dr, pass, r[Boat]);
	  if
	    :: dr == prev_dr && pass == prev_pass -> printf("Don't do the same move!\n");
	    :: else ->
	        update_r(); 
	        if          
	        :: CriminalUnsafe || BoysUnsafe || GirlsUnsafe ->  
	            update_r();
	         :: else ->          
	            prev_dr = dr; prev_pass = pass;
	        fi;
	  fi;   
	}	'''
	
	
	val inp6 = '''
	init {
	    local mtype driver    = 0; 
	    local mtype passenger = 0; 
	  
	    /* Run */    
	    do
	      /* move Cop (with anyone or alone) */
	      :: r[Cop] == r[Boat] -> driver = Cop;
	        /* Choose a 'random' passenger if it is here */
	        if
	            :: r[Criminal] == r[Boat] -> passenger = Criminal;	//TODO: have added ';' here
	            :: r[Mom] == r[Boat] -> passenger = Mom;
	            :: r[Dad] == r[Boat] -> passenger = Dad;
	            :: With(Boy,Cop) -> passenger = Boy;  
	            :: With(Girl,Cop) -> passenger = Girl;
	            :: true -> passenger = 0; /* no passenger at all */
	        fi;
	        move(driver, passenger);
	
	      /* move Dad (with a Boy or with Mom or alone) */
	      :: r[Dad] == r[Boat]  -> driver = Dad;
	        if
	            :: r[Mom] == r[Boat] -> passenger = Mom;
	            :: With(Boy,Dad) -> passenger = Boy;
	            :: true -> passenger = 0; 
	        fi;
	        move(driver, passenger);
	
	      /* move Mom (with a Girl or alone) */
	      :: r[Mom] == r[Boat]  -> driver = Mom;
	        if
	            :: With(Girl,Mom) -> passenger = Girl;  
	            :: true -> passenger = 0;
	        fi;
	        move(driver, passenger);
	  
	       :: DONE -> printf("SOLVED\n"); assert(0); break;
	       :: else -> printf("WHAT?!\n"); assert(0); break; /* Should never happen! */ 
	    od;    
	}'''
	// needed to make inp 4 run
	val inpExtra = '''
	init {
	    local mtype driver    = 0; 
	    local mtype passenger = 0; 
	    skip;
	}    
	'''

	@Test 
	def void parseProbe() {
		val result = parseHelper.parse('''
			mtype = {Cop, Criminal, Mom, Dad, Girl, Boy, Boat};
			int r[8];
			#define DONE (3 == 5)
			#define DONE (3 != (5 + 2))
			#define DONE (3 != 5 || 3 == 1)
			#define DONE (true)
			#define DONE (3 != r[4])
			#define DONE (3 != Mom)

			#define DONE (r[Cop] == 1 && r[Criminal] == 1 && 
			              r[Mom] == 1 && r[Dad] == 1 && 
			              r[Girl] == 2 && r[Boy] == 2 && r[Boat] == 1)
			
			#define NotWith(children, with) (r[children] == 2*(1-r[with]))  
			#define With(children, with)    (r[children] != 2*(1-r[with]))            
			              					''')
		Assert.assertNotNull(result)
		result.assertNoErrors
	}

	@Test 
	def void parseInp1() {
		val result = parseHelper.parse(inp1
		)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}
	
	@Test 
	def void parseInp12() {
		val result = parseHelper.parse(inp1 + inp2
		)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}

	@Test 
	def void parseInp3() {
		val result = parseHelper.parse(inp3
		)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}

	@Test 
	def void parseInp124Extra() {
		val result = parseHelper.parse(inp1 + inp2 + inp4 + inpExtra
		)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}

	@Test 
	def void parseInp12345Extra() {
		val result = parseHelper.parse(inp1 + inp2 + inp3 + inp4 + inp5 + inpExtra
		)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}

	@Test 
	def void parseInp123456() {
		val result = parseHelper.parse(inp1 + inp2 + inp3 + inp4 + inp5 + inp6
		)
		Assert.assertNotNull(result)
		result.assertNoErrors
	}


}
